Who is the target for this design, e.g., are you assuming any knowledge on the
part of the language users?

English speakers. CS experience will benefit them, since ideas of conditionals
and recursion and function calls are emulated, but the ideas are so simplified
and limited in scope that little to no cs experience should be required.


Why did you choose this design, i.e., why did you think it would be a good idea
for users to express the maze-searching computation using this syntax?

It simplifies things for the user. See below for how to solve the maze.
The states are auto-generated and abstracted. Now the user can write down directly 
in English the algorithm they would have to sweat over creating in picobot language.
And the cardinal directions are abtstracted out as well. The picobot keeps track of what 
direction it is facing.

solve maze:
    Go forwards while open in front and wall on right
    Turn Right
    Do solve maze

What behaviors are easier to express in your design than in Picobot’s original
design?  If there are no such behaviors, why not?

Moving in a direction until a certain state is achieve is simplified to one liners.
Keeping track of your orientation is abstracted out and made easy.
Breaking the problem down into parts is made easy by human readable labeled sections
and the necessary states to make a block of an algorithm happen are autogenerated.


What behaviors are more difficult to express in your design than in Picobot’s
original design? If there are no such behaviors, why not?

Not sure.

On a scale of 1–10 (where 10 is “very different”), how different is your syntax
from PicoBot’s original design?

10. The states and cardinal directions are all but completely abstracted out.

Is there anything you don’t like about your design?

It will be difficult to implement, probably.

==============================================================================

We wanted our picobot users to think about the robot having a face 
or direction that it faces. Many algorithms require keeping track of 
a wall on the left, for example, or other such relative conditions, 
and our design is aimed at making that part easy. We also wanted 
moving until a condition is met to be easy as well. Readability was 
also very important to our design decisions. With these guiding 
principles we made the following DSL design.

Each "state" is a section of commands/statements. The states are 
user defined labels that can be called from other states using a 
"Do" command (see examples). This means the user can create 
meaningfully defined states. Each statement is made to look like a 
sentence. Like "Go all the way forwards" which is syntactic sugar 
for "Go forwards until wall in front" or "Go forwards while open in 
front" which does as you imagine (moves the picobot in the direction 
you are facing until it hits a wall in that direction). Also, the 
states contain in them a sequence of commands, abstracting a lot of 
the internal states normally necessary to do such a command.

The sequence of states is very powerful. The "Go" statement itself 
comes with conditionals, like until and while, as well as the 
ability to move in a direct once. To allow the user to keep track of 
direction, the picobot can be made to "Face" any direction (up, 
down, left, right instead of cardinal) or simply turn relative to 
its heading. Important to note, a "Do" statement is essentially a 
classic go to, and not a function call. When a do is "called", it 
never returns back.

We also have a pseudo-conditional block. You can't solve things like 
mazes without checking for a condition and we wanted to remove the 
added internal states that you normally need to add just for simple 
conditions. So simple conditions, like wall on left and open on 
right, are allowed to be chained with "and". We also put an 
Otherwise in there as well as a catch all. Whenever a If is started, 
it needs to eventually end in "End" with as many additional If's 
(treated implicitly as else if) and possibly one Otherwise. We used 
End to avoid white space enforcing as well as curly braces. We 
avoided nesting of conditionals because it is not necessary for 
solving mazes.


Empty.scala
# The first section is always the starting one
get to top left corner:
    Face up
    Go all the way forwards
    Turn left
    Go all the way forwards
    Do fill in from top left
    

fill in from top left:
    Face up
    Go all the way backwards
    Go all the way forwards
    Go right once
    Do fill in from top left
    

RightHand.scala
# This way is faster but more code. It shows off conditionals
keep wall on right hard and fast:
    Go forwards while open in front and wall on right
    If open on right
        Turn right
        Do keep wall on right hard and fast
    If open on left             # implicit else if when no "End" after last "If"
        Turn left
        Do keep wall on right hard and fast
    Otherwise
        Turn around
        Do keep wall on right hard and fast
    End

# Original simple solution that turns around more than necessary
keep wall on right simple and slow:
    Go forwards while open in front and wall on right
    Turn Right
    Do keep wall on right simple and slow

    
# TODO: rewrite or delete below
start:
    do get to left corner
    face right
    do fill

get to left corner:
    face left
    go forwards until wall in front
    if open on left
        move left until open in front
        do get to left corner
    if open on right
        move right until open in front
        do get to left corner

fill first half:
    move forwards until open on right
    move all the way right (syntactic sugar for "move right until wall on right")
    move all the way left (syntactic sugar for "move left until wall on left")
    if wall in front
        do fill second half
    do fill first half
